name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [main]
  workflow_dispatch:   # Manual trigger

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: finance_db
      DB_USER: finance_user
      DB_PASSWORD: supersecret
      DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
      DOCKER_HUB_PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
      IMAGE_NAME: ${{ secrets.DOCKER_HUB_USERNAME }}/finance-tracker-app

    steps:
      # 1. Checkout latest code
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Setup .NET SDK
      - name: Setup .NET 8
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      # 3. Install dotnet tools
      - name: Install dotnet format
        run: dotnet tool install -g dotnet-format

      # 4. Run linting / code style check
      - name: Run dotnet format (check only)
        run: dotnet format --verify-no-changes

      # 5. Restore dependencies
      - name: Restore dependencies
        run: dotnet restore FinanceTrackerApp/FinanceTrackerApp.csproj

      # 6. Build the project
      - name: Build project
        run: dotnet build finance-tracker-csharp.sln --configuration Release 

      # 7. Run unit tests
      - name: Run xUnit tests
        run: dotnet test FinanceTrackerAppTest/FinanceTrackerAppTest.csproj --configuration Release --verbosity normal

      # 8. Publish the project
      - name: Publish project
        run: dotnet publish FinanceTrackerApp/FinanceTrackerApp.csproj -c Release -o ./publish

      # 9. Set Docker image tag based on date
      - name: Set image tag
        id: vars
        run: echo "IMAGE_TAG=$(date +'%Y-%m-%d')-run${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      # 10. Build Docker image
      - name: Build Docker image
        run: docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      # 11. Run Docker containers for integration test
      - name: Run Docker containers for integration test
        run: |
          set -e  # Fail on any error

          # 1. Create a temporary network
          docker network create finance_network

          # 2. Start Postgres container
          docker run -d --name postgres \
            --network finance_network \
            -e POSTGRES_USER=$DB_USER \
            -e POSTGRES_PASSWORD=$DB_PASSWORD \
            -e POSTGRES_DB=$DB_NAME \
            postgres:latest

          # 3. Wait for Postgres health
          until docker exec postgres pg_isready -U $DB_USER -d $DB_NAME; do
            echo "Postgres is unavailable - sleeping"
            sleep 2
          done

          # 4. Start app container after Postgres is healthy
          docker run -d --name test-app \
            --network finance_network \
            -e DB_HOST=postgres \
            -e DB_PORT=$DB_PORT \
            -e DB_NAME=$DB_NAME \
            -e DB_USER=$DB_USER \
            -e DB_PASSWORD=$DB_PASSWORD \
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

          # 5. Wait a few seconds for app to initialize
          sleep 10

          # 6. Fail the runner if the app fails to connect to postgres
          if echo "$APP_LOGS" | grep -q -E "An error occurred using the connection|SocketException"; then
            echo "ERROR: App failed to connect to Postgres"
            exit 1
          fi

      # 12. Stop and remove containers + network
      - name: Clean up Docker containers and network
        run: |
          docker stop test-app postgres
          docker rm test-app postgres
          docker network rm finance_network

      # 13. Login to DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      # 14. Push Docker image
      - name: Push Docker image
        run: docker push ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
